<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Genetica — BiomeCharge Concept Explorer (Standalone)</title>
  <style>
    :root{
      --bg:#060a10;
      --panel:#0c1420;
      --panel2:#09101a;
      --text:#eaf2ff;
      --muted:#a7b7cf;
      --line:#1f2c40;
      --water:#7ee7ff;
      --elec:#b6ff8a;
      --heat:#ffd36e;
      --carbon:#ff6b8b;
      --shadow: 0 18px 55px rgba(0,0,0,.55);
      --r:18px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }
    *{box-sizing:border-box}
    html, body {height:100%;}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      background:
        radial-gradient(1200px 700px at 18% 0%, rgba(126,231,255,.14), transparent 55%),
        radial-gradient(1100px 750px at 86% 14%, rgba(182,255,138,.10), transparent 55%),
        radial-gradient(900px 900px at 50% 100%, rgba(255,211,110,.09), transparent 55%),
        radial-gradient(900px 900px at 70% 65%, rgba(255,107,139,.06), transparent 60%),
        var(--bg);
      color:var(--text);
      overflow-x:hidden;
    }
    .wrap{max-width:1400px;margin:0 auto;padding:18px 14px 34px;}
    header{
      display:flex; gap:14px; align-items:flex-start; justify-content:space-between; flex-wrap:wrap;
      padding:14px 14px 12px;
      border:1px solid var(--line);
      background: linear-gradient(180deg, rgba(12,20,32,.92), rgba(9,16,26,.92));
      border-radius:var(--r);
      box-shadow:var(--shadow);
      position:relative;
      overflow:hidden;
    }
    header:before{
      content:"";
      position:absolute; inset:-20px;
      background:
        radial-gradient(600px 220px at 20% 0%, rgba(126,231,255,.10), transparent 60%),
        radial-gradient(520px 220px at 75% 10%, rgba(182,255,138,.08), transparent 60%);
      filter: blur(6px);
      pointer-events:none;
    }
    .title{position:relative;min-width:290px;max-width:930px;display:flex;flex-direction:column;gap:6px}
    h1{margin:0;font-size:18px;letter-spacing:.2px}
    .sub{margin:0;color:var(--muted);font-size:13px;line-height:1.45}
    .legend{display:flex;gap:10px;align-items:center;flex-wrap:wrap;margin-top:6px}
    .lg{display:flex;gap:8px;align-items:center;color:var(--muted);font-size:11.5px}
    .sw{width:10px;height:10px;border-radius:999px;background:var(--water)}
    .sw.e{background:var(--elec)}
    .sw.h{background:var(--heat)}
    .sw.c{background:var(--carbon)}
    .pill{
      display:inline-flex;align-items:center;gap:8px;
      padding:7px 9px;border-radius:999px;
      border:1px solid rgba(255,255,255,.08);
      background: rgba(0,0,0,.18);
      color: var(--muted);
      font-size:11.5px;font-weight:900;
    }
    .controls{position:relative;display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    .chip{
      display:flex;align-items:center;gap:10px;
      padding:8px 10px;border-radius:999px;border:1px solid var(--line);
      background:rgba(0,0,0,.14);
      color:var(--muted);font-size:12px
    }
    .btn{
      cursor:pointer;user-select:none;
      padding:9px 12px;border-radius:14px;border:1px solid var(--line);
      background:linear-gradient(180deg, rgba(17,28,44,.95), rgba(9,16,26,.95));
      color:var(--text);font-weight:900;font-size:12px
    }
    .btn:active{transform:translateY(1px)}
    input[type=range]{width:170px}
    select{
      border-radius:12px;border:1px solid var(--line);
      background:rgba(0,0,0,.14);
      color:var(--text);padding:8px 10px
    }
    .grid{display:grid;grid-template-columns:1fr;gap:14px;margin-top:14px}
    .stage{
      position:relative;
      border:1px solid var(--line);
      border-radius:var(--r);
      background:linear-gradient(180deg, rgba(12,20,32,.86), rgba(9,16,26,.86));
      box-shadow:var(--shadow);
      overflow:hidden;
      min-height:780px;
    }
    canvas{width:100%;height:100%;display:block}
    .hud{
      position:absolute;left:12px;top:12px;right:12px;
      display:flex;gap:10px;align-items:flex-start;justify-content:space-between;flex-wrap:wrap;
      pointer-events:none;
    }
    .hud .box{
      pointer-events:auto;
      background:rgba(0,0,0,.40);
      border:1px solid rgba(126,231,255,.20);
      border-radius:16px;
      padding:10px 12px;
      backdrop-filter: blur(7px);
      box-shadow: 0 12px 36px rgba(0,0,0,.35);
      max-width: 760px;
    }
    .hud .box h2{margin:0 0 6px;font-size:13px}
    .hud .box p{margin:0;color:var(--muted);font-size:12.4px;line-height:1.45}
    .hint{margin-top:8px;display:flex;gap:8px;flex-wrap:wrap;align-items:center}
    .kbd{
      font-family:var(--mono);
      font-size:11px;
      padding:4px 8px;
      border-radius:10px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(0,0,0,.22);
      color:var(--muted)
    }
    .toast{
      position:absolute;left:12px;right:12px;bottom:12px;
      background:rgba(0,0,0,.44);
      border:1px solid rgba(126,231,255,.22);
      border-radius:16px;
      padding:10px 12px;
      color:var(--muted);
      font-size:12.2px;
      line-height:1.35;
      backdrop-filter: blur(7px);
      box-shadow: 0 12px 36px rgba(0,0,0,.35)
    }
    .toast b{color:var(--text)}
    .note{
      margin-top:10px;
      border:1px solid rgba(255,255,255,.10);
      border-radius:14px;
      padding:10px 12px;
      background:rgba(0,0,0,.18);
      color:var(--muted);
      font-size:12px;
      line-height:1.45;
    }
    a{color:rgba(126,231,255,.92)}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="title">
        <h1>Genetica — BiomeCharge Concept Explorer</h1>
        <p class="sub">
          An explorable, animated concept model: <b>wind-through structure</b> → <b>motion mesh</b> → <b>conditioned DC</b>; <b>solar</b> as the anchor; <b>gravity-first water</b>; and a <b>biomass → durable carbon lock</b> loop. This preview is intentionally <b>high-level</b> so the operating principles are visible without exposing build-specs.
        </p>
        <div class="legend">
          <div class="lg"><span class="sw"></span> Water / gravity flow</div>
          <div class="lg"><span class="sw e"></span> Electricity pulses (concept)</div>
          <div class="lg"><span class="sw h"></span> Stabilization zones</div>
          <div class="lg"><span class="sw c"></span> Carbon / materials outflow</div>
          <span class="pill">Drag • Rotate • Wheel • Zoom • Click • Focus</span>
          <span class="pill">Shift+Click • Pin focus</span>
        </div>
        <div class="note">
          <b>Disclosure:</b> All on-screen indicators are <b>qualitative</b> and <b>index-based</b>. This page demonstrates system logic (growth → harvest → lock-in), not engineering dimensions, vendor stacks, or proprietary performance numbers.
        </div>
      </div>

      <div class="controls">
        <div class="chip">Sim Speed <input id="speed" type="range" min="0.4" max="2.8" step="0.1" value="1" /> <span id="speedVal">1.0×</span></div>
        <div class="chip">Floors <input id="floors" type="range" min="1" max="80" step="1" value="10" /> <span id="floorsVal">10</span></div>
        <div class="chip">Cycle <input id="cycle" type="range" min="0" max="1" step="0.001" value="0.0" /> <span id="cycleVal">Seedling</span></div>
        <div class="chip">Cycles/yr <select id="cyclesPerYear"><option value="1">1</option><option value="2">2</option><option value="3">3</option><option value="4" selected>4</option></select></div>
        <button class="btn" id="toggleAutoCycle">Auto Cycle: On</button>
        <button class="btn" id="toggleGhosts">Ghost Trails: Off</button>
        <button class="btn" id="togglePause">Pause</button>
        <button class="btn" id="toggleFX">FX: High</button>
        <button class="btn" id="reset">Reset</button>
      </div>
    </header>

    <div class="grid">
      <section class="stage" id="stage">
        <canvas id="c"></canvas>

        <div class="hud">
          <div class="box" id="focusBox">
            <h2 id="focusTitle">System in Motion</h2>
            <p id="focusText">Click on highlighted zones (canopy, spine, cistern, basin, materials) to understand how the loop works. Watch the cycle: plants thicken → harvest pulse → “durable lock” fills. Stacking only helps if light reaches each level (the model shows light-limitation shading as floors rise).</p>
            <div class="hint">
              <span class="kbd">Drag</span><span class="kbd">Rotate</span>
              <span class="kbd">Wheel</span><span class="kbd">Zoom</span>
              <span class="kbd">Click</span><span class="kbd">Focus</span>
              <span class="kbd">Shift+Click</span><span class="kbd">Pin</span>
            </div>
          </div>
        </div>

        <div class="toast" id="toast">
          <b>Live loop:</b> water cascades (cyan), electricity pulses (green), stabilization zones glow (gold), and carbon/material outflow moves (pink). The <b>Carbon Ledger</b> in the corner shows the difference between <b>temporary uptake</b> (inner ring) and <b>durable lock</b> (outer ring).
        </div>
      </section>
    </div>
  </div>

<script>
/* ==========================================================
   GENETICA — BIOMECHARGE CONCEPT EXPLORER (NO LIBS)
   Purpose: explorable visual logic with minimal disclosure.
   ========================================================== */

const DEFAULTS = {
  simSpeed: 1.0,
  floors: 10,
  fxQuality: 2, // 0 low, 1 med, 2 high

  // Biomass cycle (visual cadence)
  cycleProgress: 0.0,    // 0..1 within a cycle
  cyclesPerYear: 4,
  autoCycle: true,
  ghostTrails: false
};

const state = {...DEFAULTS, paused:false};
let pinnedFocus = false;

const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');

const speedEl = document.getElementById('speed');
const speedVal = document.getElementById('speedVal');
const floorsEl = document.getElementById('floors');
const floorsVal = document.getElementById('floorsVal');
const cycleEl = document.getElementById('cycle');
const cycleVal = document.getElementById('cycleVal');
const cyclesPerYearEl = document.getElementById('cyclesPerYear');

const toggleAutoCycle = document.getElementById('toggleAutoCycle');
const toggleGhosts = document.getElementById('toggleGhosts');
const togglePause = document.getElementById('togglePause');
const toggleFX = document.getElementById('toggleFX');
const resetBtn = document.getElementById('reset');

const focusTitle = document.getElementById('focusTitle');
const focusText = document.getElementById('focusText');

function clamp(v,min,max){return Math.max(min,Math.min(max,v));}
const fmt = { num:(n,d=1)=>Number(n).toLocaleString(undefined,{maximumFractionDigits:d}) };

function cycleLabel(p){
  if(p < 0.15) return 'Seedling';
  if(p < 0.75) return 'Growth';
  if(p < 0.90) return 'Mature';
  if(p < 0.985) return 'Harvest';
  return 'Reset';
}
function setSpeed(v){ state.simSpeed = v; speedVal.textContent = v.toFixed(1)+'×'; }
function setFloors(v){ state.floors = v; floorsVal.textContent = String(v); }
function setFX(level){
  state.fxQuality = level;
  toggleFX.textContent = level===2 ? 'FX: High' : (level===1 ? 'FX: Med' : 'FX: Low');
  seedParticles();
}

speedEl.addEventListener('input', ()=> setSpeed(parseFloat(speedEl.value)));
floorsEl.addEventListener('input', ()=> setFloors(parseInt(floorsEl.value,10)));
cycleEl.addEventListener('input', ()=>{
  state.cycleProgress = parseFloat(cycleEl.value);
  cycleVal.textContent = cycleLabel(state.cycleProgress);
});
cyclesPerYearEl.addEventListener('change', ()=>{
  state.cyclesPerYear = parseInt(cyclesPerYearEl.value,10);
});

toggleAutoCycle.addEventListener('click', ()=>{
  state.autoCycle = !state.autoCycle;
  toggleAutoCycle.textContent = state.autoCycle ? 'Auto Cycle: On' : 'Auto Cycle: Off';
});

toggleGhosts.addEventListener('click', ()=>{
  state.ghostTrails = !state.ghostTrails;
  toggleGhosts.textContent = state.ghostTrails ? 'Ghost Trails: On' : 'Ghost Trails: Off';
});

togglePause.addEventListener('click', ()=>{
  state.paused = !state.paused;
  togglePause.textContent = state.paused ? 'Play' : 'Pause';
});

toggleFX.addEventListener('click', ()=>{
  const next = (state.fxQuality + 2) % 3; // 2->1->0->2
  setFX(next);
});

resetBtn.addEventListener('click', ()=>{
  Object.assign(state, {...DEFAULTS, paused:false});
  speedEl.value='1';
  floorsEl.value='10';
  cycleEl.value='0';
  cyclesPerYearEl.value='4';
  setSpeed(1); setFloors(10);
  cycleVal.textContent = 'Seedling';
  toggleAutoCycle.textContent = 'Auto Cycle: On';
  toggleGhosts.textContent = 'Ghost Trails: Off';
  togglePause.textContent = 'Pause';
  pinnedFocus = false;
  focus('System in Motion', 'Click on highlighted zones (canopy, spine, cistern, basin, materials) to understand how the loop works. Watch the cycle: plants thicken → harvest pulse → “durable lock” fills. Stacking only helps if light reaches each level.');
  setFX(DEFAULTS.fxQuality);
});

// ------------------------------
// Minimal "ledger" model (index-based)
// ------------------------------
function compute(){
  const floors = state.floors;
  const p = clamp(state.cycleProgress,0,1);

  // Growth curve: seedling → growth → mature → harvest taper → reset
  const g1 = clamp(p/0.15,0,1)*0.18;
  const g2 = 0.18 + clamp((p-0.15)/0.60,0,1)*0.82;
  const growth = (p < 0.15) ? g1 : (p < 0.75) ? g2 : (p < 0.90) ? 1.0 : (p < 0.985) ? (1.0 - clamp((p-0.90)/0.085,0,1)*0.25) : 0.0;

  // Light-limited stacking (visual cue only)
  const stackLightEff = clamp(1 - Math.max(0, floors-10)*0.015, 0.45, 1.0);

  // Index-based annual potentials (no absolute performance numbers)
  const grossYear = 1.0 * stackLightEff;
  const grossCurrent = grossYear * clamp(growth,0,1);

  // Lock only fills during harvest window, then resets
  const lockYear = 0.70 * stackLightEff;
  const harvestFill = (p >= 0.90 && p < 0.985) ? clamp((p-0.90)/0.085,0,1) : 0.0;
  const lockCurrent = lockYear * harvestFill;

  return { grossYear, grossCurrent, lockYear, lockCurrent, stackLightEff, growth };
}

// ------------------------------
// Focus subsystem messaging (no numbers)
// ------------------------------
const FOCUS = {
  solar:{ title:'Solar Canopy (anchor)',
    text:()=> 'Solar is the stability layer: consistent baseline energy that keeps the loop alive when wind is quiet.' },
  piezo:{ title:'Motion Mesh (wind-to-signal)',
    text:()=> 'The motion mesh turns sway into usable pulses (and sensing). The model shows pulses—exact hardware details are intentionally abstracted.' },
  water:{ title:'Gravity Hydrology (cistern → trays)',
    text:()=> 'Water is positioned at height, then distributed by gravity. This reduces hidden energy drain and supports repeatable cycling.' },
  hydro:{ title:'Micro-recovery (optional)',
    text:()=> 'A recovery zone can reclaim small amounts of head. In the concept, it’s shown as a quiet reinforcement layer.' },
  microbial:{ title:'Soil / microbial zones',
    text:()=> 'Microbial and soil zones act like the system’s “nervous system”—sensing, buffering, and supporting stable growth.' },
  spine:{ title:'DC Spine (aggregation)',
    text:()=> 'Everything reports into one measurable backbone: unify, buffer, and export where possible. Finance comes from what you can meter.' },
  heat:{ title:'Stabilization zones',
    text:()=> 'Instead of heating a whole building, stabilization happens where it matters: protect electronics, plumbing, and root zones.' },
  carbon:{ title:'Carbon pipeline (growth → lock)',
    text:()=> 'Inner ring shows temporary uptake during growth. Outer ring fills only at harvest—when biomass is routed into durable storage pathways.' },
  storage:{ title:'Storage (smoothing)',
    text:()=> 'Storage turns variable input into steady operation. In this preview, it’s shown as flow continuity—not a vendor spec.' }
};

function focus(title, text){
  focusTitle.textContent = title;
  focusText.textContent = text;
}

// ------------------------------
// Lightweight 3D engine
// ------------------------------
const cam = { rotX:-0.55, rotY:0.85, dist:3.2, w:0, h:0, scale:220 };

function resize(){
  const dpr = Math.max(1, Math.min(2.5, window.devicePixelRatio || 1));
  const rect = canvas.getBoundingClientRect();
  canvas.width = Math.floor(rect.width * dpr);
  canvas.height = Math.floor(rect.height * dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);
  cam.w = rect.width; cam.h = rect.height;
}
window.addEventListener('resize', resize);

function rotX(p,a){ const s=Math.sin(a), c=Math.cos(a); return {x:p.x, y:p.y*c - p.z*s, z:p.y*s + p.z*c}; }
function rotY(p,a){ const s=Math.sin(a), c=Math.cos(a); return {x:p.x*c + p.z*s, y:p.y, z:-p.x*s + p.z*c}; }

function project(p){
  let q = rotY(p, cam.rotY);
  q = rotX(q, cam.rotX);
  q.z += cam.dist;
  const f = cam.scale / q.z;
  return {x: cam.w*0.5 + q.x*f, y: cam.h*0.52 + q.y*f, f, z:q.z};
}

// ------------------------------
// Scene
// ------------------------------
const scene = {
  t: 0,
  waterParticles: [],
  elecParticles: [],
  heatParticles: [],
  carbonParticles: [],
  stars: [],
  picks: [],
  harvestFlash: 0
};

function seedParticles(){
  const q = state.fxQuality;
  const mul = q===2 ? 1 : (q===1 ? 0.65 : 0.35);

  scene.waterParticles.length = 0;
  scene.elecParticles.length = 0;
  scene.heatParticles.length = 0;
  scene.carbonParticles.length = 0;

  const wN = Math.floor(140*mul);
  const eN = Math.floor(110*mul);
  const hN = Math.floor(90*mul);
  const cN = Math.floor(80*mul);

  for(let i=0;i<wN;i++) scene.waterParticles.push({a:Math.random(), v:0.12+Math.random()*0.30});
  for(let i=0;i<eN;i++) scene.elecParticles.push({a:Math.random(), v:0.18+Math.random()*0.45});
  for(let i=0;i<hN;i++) scene.heatParticles.push({a:Math.random(), v:0.07+Math.random()*0.25});
  for(let i=0;i<cN;i++) scene.carbonParticles.push({a:Math.random(), v:0.06+Math.random()*0.20});

  if(scene.stars.length===0){
    for(let i=0;i<160;i++){
      scene.stars.push({x:Math.random(), y:Math.random(), r:Math.random()*1.4, a:0.12+Math.random()*0.35, tw:Math.random()*1.2});
    }
  }
}

// ------------------------------
// Geometry helpers
// ------------------------------
function lerp(a,b,t){return a+(b-a)*t;}

function drawLine3D(a,b, stroke, w=2, alpha=1){
  const A = project(a), B = project(b);
  ctx.globalAlpha = alpha;
  ctx.strokeStyle = stroke;
  ctx.lineWidth = w;
  ctx.beginPath();
  ctx.moveTo(A.x, A.y);
  ctx.lineTo(B.x, B.y);
  ctx.stroke();
  ctx.globalAlpha = 1;
}

function drawCircle2D(x,y,r, color, alpha=1){
  ctx.globalAlpha = alpha;
  ctx.fillStyle = color;
  ctx.beginPath();
  ctx.arc(x,y,r,0,Math.PI*2);
  ctx.fill();
  ctx.globalAlpha = 1;
}

function drawQuad3D(p1,p2,p3,p4, fill, stroke, alpha=1){
  const a=project(p1), b=project(p2), c=project(p3), d=project(p4);
  ctx.globalAlpha = alpha;
  ctx.fillStyle = fill;
  ctx.strokeStyle = stroke;
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); ctx.lineTo(c.x,c.y); ctx.lineTo(d.x,d.y);
  ctx.closePath(); ctx.fill(); ctx.stroke();
  ctx.globalAlpha = 1;
  const xs=[a.x,b.x,c.x,d.x], ys=[a.y,b.y,c.y,d.y];
  return {minX:Math.min(...xs), minY:Math.min(...ys), maxX:Math.max(...xs), maxY:Math.max(...ys)};
}
function addPick(key, bbox){ scene.picks.push({key, ...bbox}); }

// ------------------------------
// Interaction: drag rotate + wheel zoom + click pick
// ------------------------------
let dragging=false;
let lastX=0, lastY=0;

canvas.addEventListener('pointerdown', (e)=>{
  dragging=true;
  canvas.setPointerCapture(e.pointerId);
  lastX=e.clientX; lastY=e.clientY;
});
canvas.addEventListener('pointerup', (e)=>{
  dragging=false;
  try{canvas.releasePointerCapture(e.pointerId);}catch(_){}
});
canvas.addEventListener('pointermove', (e)=>{
  if(!dragging) return;
  const dx = (e.clientX-lastX);
  const dy = (e.clientY-lastY);
  lastX=e.clientX; lastY=e.clientY;
  cam.rotY += dx*0.006;
  cam.rotX += dy*0.006;
  cam.rotX = clamp(cam.rotX, -1.45, 0.25);
});

canvas.addEventListener('wheel', (e)=>{
  e.preventDefault();
  cam.dist += e.deltaY*0.0015;
  cam.dist = clamp(cam.dist, 1.6, 6.5);
}, {passive:false});

canvas.addEventListener('click', (e)=>{
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  const pin = e.shiftKey;

  for(let i=scene.picks.length-1;i>=0;i--){
    const p=scene.picks[i];
    if(x>=p.minX && x<=p.maxX && y>=p.minY && y<=p.maxY){
      const d = FOCUS[p.key];
      if(d){
        pinnedFocus = pin;
        focus(d.title + (pin ? ' (Pinned)' : ''), d.text());
      }
      return;
    }
  }
  if(!pinnedFocus){
    focus('System in Motion', 'Click on highlighted zones (canopy, spine, cistern, basin, materials) to understand how the loop works. Watch the cycle: plants thicken → harvest pulse → “durable lock” fills. Stacking only helps if light reaches each level.');
  }
});

// ------------------------------
// Draw helpers
// ------------------------------
function clear(){
  ctx.clearRect(0,0,cam.w,cam.h);

  // stars
  ctx.save();
  for(const s of scene.stars){
    const tw = 0.35 + 0.65*Math.abs(Math.sin(scene.t*0.35 + s.tw));
    ctx.globalAlpha = s.a * tw;
    ctx.fillStyle = 'rgba(255,255,255,1)';
    ctx.beginPath();
    ctx.arc(s.x*cam.w, s.y*cam.h*0.55, s.r, 0, Math.PI*2);
    ctx.fill();
  }
  ctx.restore();

  // soft vignette
  const g = ctx.createRadialGradient(cam.w*0.5, cam.h*0.55, 70, cam.w*0.5, cam.h*0.55, Math.max(cam.w,cam.h)*0.85);
  g.addColorStop(0,'rgba(255,255,255,0.00)');
  g.addColorStop(1,'rgba(0,0,0,0.38)');
  ctx.fillStyle=g;
  ctx.fillRect(0,0,cam.w,cam.h);
}

function drawSky(){
  ctx.save();
  ctx.globalAlpha = 0.16;
  ctx.strokeStyle = 'rgba(255,255,255,0.14)';
  ctx.lineWidth = 1;
  for(let i=0;i<10;i++){
    const y = cam.h*0.12 + i*18;
    ctx.beginPath();
    ctx.moveTo(cam.w*0.08, y);
    ctx.bezierCurveTo(cam.w*0.25, y-10, cam.w*0.65, y+6, cam.w*0.92, y-4);
    ctx.stroke();
  }
  ctx.restore();
}

function drawTower(){
  scene.picks.length = 0;
  const floors = state.floors;
  const visualFloors = Math.min(floors, 28);

  const W = 1.35, D = 0.88, H = 2.05;
  const yBase = 0.95, yTop = yBase - H;
  const step = H / Math.max(1, visualFloors);

  const wind = 0.12 + 0.003*Math.min(60,floors);

  // Biomass phase visuals
  const p = clamp(state.cycleProgress,0,1);
  const g1 = clamp(p/0.15,0,1)*0.18;
  const g2 = 0.18 + clamp((p-0.15)/0.60,0,1)*0.82;
  const growth = (p < 0.15) ? g1 : (p < 0.75) ? g2 : (p < 0.90) ? 1.0 : (p < 0.985) ? (1.0 - clamp((p-0.90)/0.085,0,1)*0.25) : 0.0;
  const stackLightEff = clamp(1 - Math.max(0, floors-10)*0.015, 0.45, 1.0);

  // Ground
  drawQuad3D({x:-2.8,y:yBase+0.30,z:-2.2},{x:2.8,y:yBase+0.30,z:-2.2},{x:2.8,y:yBase+0.30,z:2.4},{x:-2.8,y:yBase+0.30,z:2.4},
    'rgba(0,0,0,0.22)','rgba(255,255,255,0.06)',0.9);

  // Ghost trails (multi-year intuition)
  if(state.ghostTrails){
    for(let gI=1; gI<=6; gI++){
      const a = 0.12 * (1 - gI/7);
      const ox = -0.26*gI;
      const oz = 0.22*gI;
      drawLine3D({x:W*0.56+ox, y:yTop-0.05, z:D*0.20+oz},{x:W*0.56+ox, y:yBase+0.12, z:D*0.20+oz}, 'rgba(182,255,138,0.10)', 3.0, a);
      drawQuad3D({x:-W*0.65+ox,y:yTop-0.25,z:-D*0.65+oz},{x:W*0.85+ox,y:yTop-0.25,z:-D*0.65+oz},{x:W*0.85+ox,y:yTop-0.25,z:D*0.85+oz},{x:-W*0.65+ox,y:yTop-0.25,z:D*0.85+oz},
        'rgba(126,231,255,0.02)','rgba(126,231,255,0.06)', a);
      drawQuad3D({x:-W*0.70+ox,y:yBase-H*0.98,z:-D*0.70+oz},{x:W*0.70+ox,y:yBase-H*0.98,z:-D*0.70+oz},{x:W*0.70+ox,y:yBase+0.10,z:D*0.70+oz},{x:-W*0.70+ox,y:yBase+0.10,z:D*0.70+oz},
        'rgba(255,255,255,0.008)','rgba(255,255,255,0.02)', a);
    }
  }

  // DC spine
  const spineA = {x: W*0.56, y:yTop-0.05, z: D*0.20};
  const spineB = {x: W*0.56, y:yBase+0.12, z: D*0.20};
  drawLine3D(spineA, spineB, 'rgba(182,255,138,0.35)', 4.6, 0.95);
  drawLine3D(spineA, spineB, 'rgba(182,255,138,0.12)', 12.0, 0.55);

  const pulseY = lerp(yBase+0.10, yTop-0.06, (Math.sin(scene.t*1.2)*0.5+0.5));
  const Pp = project({x:W*0.56,y:pulseY,z:D*0.20});
  drawCircle2D(Pp.x,Pp.y,10,'rgba(182,255,138,0.22)',0.35);
  drawCircle2D(Pp.x,Pp.y,4,'rgba(182,255,138,0.75)',0.85);
  addPick('spine', {minX:Pp.x-18,minY:Math.min(Pp.y,project(spineA).y)-18,maxX:Pp.x+18,maxY:Math.max(Pp.y,project(spineB).y)+18});

  // Solar canopy
  const sY = yTop - 0.25;
  const bboxSolar = drawQuad3D({x:-W*0.65,y:sY,z:-D*0.65},{x:W*0.85,y:sY,z:-D*0.65},{x:W*0.85,y:sY,z:D*0.85},{x:-W*0.65,y:sY,z:D*0.85},
    'rgba(126,231,255,0.08)','rgba(126,231,255,0.18)',0.96);
  addPick('solar', bboxSolar);
  const A=project({x:0,y:sY,z:0});
  drawCircle2D(A.x,A.y,40,'rgba(126,231,255,0.25)',0.20);

  // Top cistern
  const yC = yTop - 0.10;
  const bboxWater = drawQuad3D({x:-W*0.55,y:yC,z:-D*0.12},{x:-W*0.10,y:yC,z:-D*0.12},{x:-W*0.10,y:yC,z:D*0.30},{x:-W*0.55,y:yC,z:D*0.30},
    'rgba(126,231,255,0.08)','rgba(126,231,255,0.22)',1);
  addPick('water', bboxWater);

  // Storage cabinet near spine
  const yS = yBase - H*0.05;
  const bboxStor = drawQuad3D({x:W*0.60,y:yS,z:-D*0.05},{x:W*0.92,y:yS,z:-D*0.05},{x:W*0.92,y:yS,z:D*0.22},{x:W*0.60,y:yS,z:D*0.22},
    'rgba(182,255,138,0.05)','rgba(182,255,138,0.20)',0.98);
  addPick('storage', bboxStor);

  // Base basin
  addPick('water', drawQuad3D({x:-W*0.74,y:yBase+0.20,z:-D*0.74},{x:W*0.80,y:yBase+0.20,z:-D*0.74},{x:W*0.80,y:yBase+0.20,z:-D*0.08},{x:-W*0.74,y:yBase+0.20,z:-D*0.08},
    'rgba(126,231,255,0.06)','rgba(255,255,255,0.07)',0.95));

  // Micro-hydro block
  addPick('hydro', drawQuad3D({x:W*0.20,y:yBase+0.07,z:-D*0.55},{x:W*0.55,y:yBase+0.07,z:-D*0.55},{x:W*0.55,y:yBase+0.07,z:-D*0.30},{x:W*0.20,y:yBase+0.07,z:-D*0.30},
    'rgba(126,231,255,0.05)','rgba(126,231,255,0.18)',0.95));

  // Microbial zone
  addPick('microbial', drawQuad3D({x:-W*0.62,y:yBase - H*0.35,z:D*0.40},{x:-W*0.20,y:yBase - H*0.35,z:D*0.40},{x:-W*0.20,y:yBase - H*0.35,z:D*0.72},{x:-W*0.62,y:yBase - H*0.35,z:D*0.72},
    'rgba(255,211,110,0.06)','rgba(255,211,110,0.22)',1));

  // Heat zone
  addPick('heat', drawQuad3D({x:W*0.60,y:yBase - H*0.15,z:D*0.38},{x:W*0.86,y:yBase - H*0.15,z:D*0.38},{x:W*0.86,y:yBase - H*0.15,z:D*0.66},{x:W*0.60,y:yBase - H*0.15,z:D*0.66},
    'rgba(255,211,110,0.05)','rgba(255,211,110,0.20)',0.98));

  // Carbon outflow block
  addPick('carbon', drawQuad3D({x:W*0.85,y:yBase + 0.22,z:D*0.15},{x:W*1.25,y:yBase + 0.22,z:D*0.15},{x:W*1.25,y:yBase + 0.22,z:D*0.55},{x:W*0.85,y:yBase + 0.22,z:D*0.55},
    'rgba(255,107,139,0.05)','rgba(255,107,139,0.22)',0.98));

  // Floors + plants
  for(let i=0;i<visualFloors;i++){
    const y = yBase - i*step;
    const t = i/Math.max(1,visualFloors-1);

    const w = lerp(W*0.70, W, t);
    const d = lerp(D*0.60, D, t);

    // Light limitation shading per floor (more floors → darker = more limited)
    const floorShade = clamp(stackLightEff * (1 - t*0.12), 0.35, 1.0);
    drawQuad3D({x:-w,y:y,z:-d},{x:w,y:y,z:-d},{x:w,y:y,z:d},{x:-w,y:y,z:d},
      `rgba(126,231,255,${0.02*floorShade})`,'rgba(255,255,255,0.06)',0.85);

    drawLine3D({x:-w*0.92,y:y+0.001,z:0},{x:w*0.92,y:y+0.001,z:0},`rgba(126,231,255,${0.08*floorShade})`,2.1,0.85);

    const count = 9;
    for(let k=0;k<count;k++){
      const gx = ((k%3)-1)*w*0.36;
      const gz = (Math.floor(k/3)-1)*d*0.36;

      const sway = Math.sin(scene.t*1.6 + i*0.35 + k*0.8)*wind*0.22;
      const sway2= Math.cos(scene.t*1.1 + k*0.6)*wind*0.12;
      const base={x:gx,y:y,z:gz};

      // plant height & thickness scale with growth
      const h = 0.05 + 0.16*growth;
      const tip={x:gx+sway*(0.55+0.65*growth), y:y-h, z:gz+sway2*(0.55+0.65*growth)};

      const thick = 1.4 + 1.2*growth;
      drawLine3D(base, tip, `rgba(182,255,138,${0.18 + 0.22*growth})`, thick, 0.90);
      const T = project(tip);
      drawCircle2D(T.x,T.y,2.2+1.0*growth,'rgba(182,255,138,0.55)',0.75);

      if(k%2===0){
        const a={x:gx-0.10,y:y-0.01,z:gz-0.08};
        const b={x:gx+sway*0.65,y:y-0.06,z:gz+sway2*0.55};
        const c={x:gx+0.14,y:y-0.01,z:gz+0.10};
        drawLine3D(a,b,`rgba(182,255,138,${0.10+0.12*growth})`,1.4,0.8);
        drawLine3D(b,c,`rgba(182,255,138,${0.10+0.12*growth})`,1.4,0.8);
      }
    }
  }

  // Piezo pick zone (mid)
  addPick('piezo', drawQuad3D({x:-W*0.22,y:yBase - H*0.55,z:-D*0.22},{x:W*0.22,y:yBase - H*0.55,z:-D*0.22},{x:W*0.22,y:yBase - H*0.55,z:D*0.22},{x:-W*0.22,y:yBase - H*0.55,z:D*0.22},
    'rgba(182,255,138,0.02)','rgba(182,255,138,0.20)',0.01));
}

function drawParticles(){
  const W=1.35, D=0.88, H=2.05;
  const yBase=0.95, yTop=yBase-H;

  const p = clamp(state.cycleProgress,0,1);
  const g1 = clamp(p/0.15,0,1)*0.18;
  const g2 = 0.18 + clamp((p-0.15)/0.60,0,1)*0.82;
  const growth = (p < 0.15) ? g1 : (p < 0.75) ? g2 : (p < 0.90) ? 1.0 : (p < 0.985) ? (1.0 - clamp((p-0.90)/0.085,0,1)*0.25) : 0.0;

  // Water
  for(const pz of scene.waterParticles){
    const a = (pz.a + scene.t*pz.v) % 1;
    const y = lerp(yTop-0.06, yBase+0.15, a);
    const P = project({x:-0.05,y,z:0.08});
    drawCircle2D(P.x,P.y,2.4,'rgba(126,231,255,0.75)',0.78);
  }
  // Electricity
  for(const pz of scene.elecParticles){
    const a = (pz.a + scene.t*pz.v) % 1;
    const y = lerp(yBase+0.12, yTop-0.05, a);
    const P = project({x:W*0.56,y,z:D*0.20});
    drawCircle2D(P.x,P.y,2.3,'rgba(182,255,138,0.75)',0.86);
  }
  // Heat
  for(const pz of scene.heatParticles){
    const a = (pz.a + scene.t*pz.v) % 1;
    const y = lerp(yBase- H*0.12, yBase- H*0.28, a);
    const x = lerp(W*0.62, W*0.82, (Math.sin((pz.a+scene.t)*6)+1)*0.5);
    const z = lerp(D*0.40, D*0.62, (Math.cos((pz.a+scene.t)*5)+1)*0.5);
    const P = project({x,y,z});
    drawCircle2D(P.x,P.y,2.7,'rgba(255,211,110,0.68)',0.46);
  }
  // Carbon (scales with growth; surges on harvest)
  const harvestBoost = 1 + 1.25*scene.harvestFlash;
  for(const pz of scene.carbonParticles){
    const a = (pz.a + scene.t*pz.v*harvestBoost) % 1;
    const x = lerp(0.0, 1.60, a);
    const y = lerp(yBase-0.18, yBase+0.22, a);
    const z = lerp(0.15, 0.55, (Math.sin((pz.a+scene.t)*4)+1)*0.5);
    const P = project({x,y,z});
    const r = (2.0 + 1.2*growth) * (1 + 0.35*scene.harvestFlash);
    const alpha = 0.38 + 0.28*growth;
    drawCircle2D(P.x,P.y,r,'rgba(255,107,139,0.80)',alpha);
  }

  // Wind streaks
  ctx.save();
  ctx.globalAlpha = 0.17;
  ctx.strokeStyle = 'rgba(255,255,255,0.16)';
  ctx.lineWidth = 1.5;
  for(let i=0;i<8;i++){
    const yy = cam.h*0.25 + i*36;
    const off = Math.sin(scene.t*0.6 + i)*18;
    ctx.beginPath();
    ctx.moveTo(cam.w*0.06, yy);
    ctx.bezierCurveTo(cam.w*0.18, yy-12+off, cam.w*0.42, yy+10-off, cam.w*0.55, yy-4);
    ctx.stroke();
  }
  ctx.restore();
}

function drawLabels(){
  const W=1.35, D=0.88, H=2.05;
  const yBase=0.95, yTop=yBase-H;

  function labelAt(p, txt, color){
    const P = project(p);
    ctx.save();
    ctx.font = '12px ui-sans-serif, system-ui';
    ctx.fillStyle = color;
    ctx.globalAlpha = 0.92;
    ctx.fillText(txt, P.x+8, P.y-6);
    ctx.restore();
  }
  labelAt({x:0,y:yTop-0.25,z:0}, 'Canopy', 'rgba(126,231,255,0.85)');
  labelAt({x:W*0.56,y:yTop-0.12,z:D*0.20}, 'Spine', 'rgba(182,255,138,0.85)');
  labelAt({x:-0.55,y:yTop-0.10,z:0.05}, 'Cistern', 'rgba(126,231,255,0.85)');
  labelAt({x:W*0.76,y:yBase- H*0.05,z:D*0.10}, 'Storage', 'rgba(182,255,138,0.85)');
  labelAt({x:-0.55,y:yBase- H*0.35,z:D*0.60}, 'Soil zone', 'rgba(255,211,110,0.85)');
  labelAt({x:W*0.75,y:yBase- H*0.15,z:D*0.52}, 'Stabilize', 'rgba(255,211,110,0.85)');
  labelAt({x:W*0.35,y:yBase+0.07,z:-D*0.40}, 'Recovery', 'rgba(126,231,255,0.85)');
  labelAt({x:W*1.05,y:yBase+0.22,z:D*0.35}, 'Materials', 'rgba(255,107,139,0.85)');
}

function drawLedgers(){
  const m = compute();
  const x = 22;
  const y = cam.h - 120;
  const r1 = 34;
  const r2 = 46;

  ctx.save();
  ctx.globalAlpha = 0.55;
  ctx.fillStyle = 'rgba(0,0,0,0.35)';
  ctx.strokeStyle = 'rgba(126,231,255,0.18)';
  ctx.lineWidth = 1;
  ctx.beginPath();
  if(ctx.roundRect){
    ctx.roundRect(x-12, y-64, 230, 108, 16);
  }else{
    ctx.rect(x-12, y-64, 230, 108);
  }
  ctx.fill();
  ctx.stroke();

  ctx.globalAlpha = 0.95;
  ctx.fillStyle = 'rgba(234,242,255,0.95)';
  ctx.font = '12px ui-sans-serif, system-ui';
  ctx.fillText('Carbon Ledger (cycle view)', x, y-44);
  ctx.font = '11px ui-sans-serif, system-ui';
  ctx.fillStyle = 'rgba(167,183,207,0.95)';
  ctx.fillText('Inner: Temporary uptake', x+96, y-12);
  ctx.fillText('Outer: Durable lock', x+96, y+8);

  const grossP = clamp(m.grossCurrent / Math.max(0.0001, m.grossYear), 0, 1);
  const lockP  = clamp(m.lockCurrent  / Math.max(0.0001, m.lockYear), 0, 1);

  function ring(r, p, color, bgAlpha){
    ctx.lineCap = 'round';
    ctx.lineWidth = 9;
    ctx.strokeStyle = `rgba(255,255,255,${bgAlpha})`;
    ctx.beginPath();
    ctx.arc(x+r, y, r, -Math.PI*0.5, Math.PI*1.5);
    ctx.stroke();
    ctx.strokeStyle = color;
    ctx.beginPath();
    ctx.arc(x+r, y, r, -Math.PI*0.5, -Math.PI*0.5 + Math.PI*2*p);
    ctx.stroke();
  }

  ring(r1, grossP, 'rgba(255,107,139,0.85)', 0.10);
  ring(r2, lockP,  'rgba(182,255,138,0.85)', 0.08);

  ctx.fillStyle = 'rgba(234,242,255,0.92)';
  ctx.font = '11px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace';
  ctx.fillText(`Uptake: ${fmt.num(grossP*100,0)}%`, x, y+44);
  ctx.fillText(`Lock:   ${fmt.num(lockP*100,0)}%`, x+110, y+44);

  if(scene.harvestFlash > 0.02){
    ctx.globalAlpha = 0.25*scene.harvestFlash;
    ctx.strokeStyle = 'rgba(255,107,139,0.75)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(x+r2, y, r2+14, 0, Math.PI*2);
    ctx.stroke();
  }
  ctx.restore();
}

// ------------------------------
// Animation loop
// ------------------------------
let lastTs = performance.now();
function tick(ts){
  const dt = Math.min(0.05, (ts-lastTs)/1000);
  lastTs = ts;

  if(!state.paused){
    scene.t += 0.016 * state.simSpeed;

    // Auto cycle (visual cadence)
    if(state.autoCycle){
      const baseCycleSeconds = 10; // at cyclesPerYear=4 and simSpeed=1
      const rate = (state.cyclesPerYear / 4) / baseCycleSeconds;
      state.cycleProgress += dt * state.simSpeed * rate;
      if(state.cycleProgress >= 1){
        state.cycleProgress = state.cycleProgress % 1;
        scene.harvestFlash = 1.0;
      }
      cycleEl.value = state.cycleProgress.toFixed(3);
      cycleVal.textContent = cycleLabel(state.cycleProgress);
    }

    // harvest flash decay
    scene.harvestFlash *= Math.pow(0.02, dt);
  }

  clear();
  drawSky();
  drawTower();
  drawParticles();
  drawLabels();
  drawLedgers();
  requestAnimationFrame(tick);
}

// ------------------------------
// Boot
// ------------------------------
function init(){
  resize();
  setSpeed(state.simSpeed);
  setFloors(state.floors);
  cycleVal.textContent = cycleLabel(state.cycleProgress);
  setFX(state.fxQuality);
  seedParticles();
  requestAnimationFrame(tick);
}

seedParticles();
init();
</script>
</body>
</html>
